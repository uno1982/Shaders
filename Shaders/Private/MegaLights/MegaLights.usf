// Copyright Epic Games, Inc. All Rights Reserved.

// When loading SSS checkerboard pixel, do not adjust DiffuseColor/SpecularColor to preserve specular and diffuse lighting values for each pixel
#define ALLOW_SSS_MATERIAL_OVERRIDE 0

#include "../Common.ush"
#include "MegaLightsShading.ush"

groupshared uint SharedTileMode[THREADGROUP_SIZE * THREADGROUP_SIZE];

RWStructuredBuffer<uint> RWTileAllocator;
RWStructuredBuffer<uint> RWTileData;
uint TileDataStride;
uint DownsampledTileDataStride;
uint2 DownsampledViewMin;
uint2 DownsampledViewSize;
uint EnableTexturedRectLights;

#ifdef TileClassificationCS

/**
 * Run tile classification to generate tiles for each subsequent pass
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void TileClassificationCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint LinearThreadIndex = GroupThreadId.x + THREADGROUP_SIZE * GroupThreadId.y;

	SharedTileMode[LinearThreadIndex] = 0;
	
	GroupMemoryBarrierWithGroupSync();

#if DOWNSAMPLED_CLASSIFICATION
	uint2 ScreenCoord = DispatchThreadId.xy + DownsampledViewMin;
	if (all(ScreenCoord < DownsampledViewMin + DownsampledViewSize))
#else
	uint2 ScreenCoord = DispatchThreadId.xy + View.ViewRectMinAndSize.xy;
	if (all(ScreenCoord < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
#endif
	{
#if DOWNSAMPLED_CLASSIFICATION
		float2 ScreenUV = DownsampledScreenCoordToScreenUV(ScreenCoord);
		uint2 EffectiveScreenCoord = DownsampledScreenCoordToScreenCoord(ScreenCoord);
#else
		float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
		uint2 EffectiveScreenCoord = ScreenCoord;
#endif
		FMegaLightsMaterial Material = LoadMaterial(ScreenUV, EffectiveScreenCoord);

		uint TileMode = 0;

		if (!Material.IsValid())
		{
			TileMode = 0x1;
		}
		else if (Material.IsSimple())
		{
			TileMode = 0x2;
		}
		else
		{
			TileMode = 0x4;
		}

		const float SceneDepth = Material.Depth;

		const uint EyeIndex = 0;
		const uint GridIndex = ComputeLightGridCellIndex(EffectiveScreenCoord, SceneDepth, EyeIndex);
		const FCulledLightsGridHeader CulledLightGridHeader = GetCulledLightsGridHeader(GridIndex, EyeIndex);

		if (CulledLightGridHeader.bHasRectLight)
		{
			TileMode |= 0x8;
		}

		if (CulledLightGridHeader.bHasTexturedLight && EnableTexturedRectLights != 0)
		{
			TileMode |= 0x10;
		}

		SharedTileMode[LinearThreadIndex] = TileMode;
	}

	GroupMemoryBarrierWithGroupSync();

	// GroupShared reduction
	if (LinearThreadIndex < 32)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 32];
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < 16)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 16];
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < 8)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 8];
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < 4)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 4];
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < 2)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 2];
	}

	GroupMemoryBarrierWithGroupSync();

	if (LinearThreadIndex < 1)
	{
		SharedTileMode[LinearThreadIndex] = SharedTileMode[LinearThreadIndex] | SharedTileMode[LinearThreadIndex + 1];
	}

	if (LinearThreadIndex == 0)
	{
#if DOWNSAMPLED_CLASSIFICATION
		const uint DataStride = DownsampledTileDataStride;
#else
		const uint DataStride = TileDataStride;
#endif

		uint2 TileCoord = ScreenCoord / TILE_SIZE;

		int TileMode = -1;

		if (SharedTileMode[0] & 0x4)
		{
			TileMode = TILE_MODE_COMPLEX_SHADING;

			if (SharedTileMode[0] & 0x8)
			{
				if (SharedTileMode[0] & 0x10)
				{
					TileMode = TILE_MODE_COMPLEX_SHADING_RECT_TEXTURED;
				}
				else
				{
					TileMode = TILE_MODE_COMPLEX_SHADING_RECT;
				}
			}
		}
		else if (SharedTileMode[0] & 0x2)
		{
			TileMode = TILE_MODE_SIMPLE_SHADING;

			if (SharedTileMode[0] & 0x8)
			{
				if (SharedTileMode[0] & 0x10)
				{
					TileMode = TILE_MODE_SIMPLE_SHADING_RECT_TEXTURED;
				}
				else
				{
					TileMode = TILE_MODE_SIMPLE_SHADING_RECT;
				}
			}
		}
		else if (SharedTileMode[0] & 0x1)
		{
			TileMode = TILE_MODE_EMPTY;
		}

		if (TileMode >= 0)
		{
			uint MegaLightsTileIndex;
			InterlockedAdd(RWTileAllocator[TileMode], 1, MegaLightsTileIndex);
			RWTileData[DataStride * TileMode + MegaLightsTileIndex] = PackTile(TileCoord);
		}
	}
}

#endif

RWBuffer<uint> RWTileIndirectArgs;
RWBuffer<uint> RWDownsampledTileIndirectArgs;
StructuredBuffer<uint> TileAllocator;
StructuredBuffer<uint> DownsampledTileAllocator;

#ifdef InitTileIndirectArgsCS

[numthreads(THREADGROUP_SIZE, 1, 1)]
void InitTileIndirectArgsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint TileMode = DispatchThreadId.x;
	if (TileMode < TILE_MODE_MAX)
	{
		WriteDispatchIndirectArgs(RWTileIndirectArgs, TileMode, TileAllocator[TileMode], 1, 1);
		WriteDispatchIndirectArgs(RWDownsampledTileIndirectArgs, TileMode, DownsampledTileAllocator[TileMode], 1, 1);
	}
}

#endif

RWTexture2D<float4> RWCompositeUpsampleWeights;

Texture2D<float> DownsampledSceneDepth;
float2 DownsampledBufferInvSize;

#ifdef InitCompositeUpsampleWeightsCS

bool IsValidDownsampledCoord(uint2 DownsampledScreenCoord)
{
	return all(DownsampledScreenCoord.xy < DownsampledViewMin + DownsampledViewSize);
}	

/**
 * Prepare weights for upsampling in order to pull out common per pixel composite work into a separate dispatch.
 */
[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void InitCompositeUpsampleWeightsCS(
	uint3 GroupId : SV_GroupID,
	uint3 GroupThreadId : SV_GroupThreadID,
	uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint2 ScreenCoord = DispatchThreadId.xy + View.ViewRectMinAndSize.xy;

	if (all(ScreenCoord < View.ViewRectMinAndSize.xy + View.ViewRectMinAndSize.zw))
	{
		float2 ScreenUV = (ScreenCoord + 0.5f) * View.BufferSizeAndInvSize.zw;
		const FMegaLightsMaterial Material = LoadMaterial(ScreenUV, ScreenCoord);
		float3 TranslatedWorldPosition = GetTranslatedWorldPositionFromScreenUV(ScreenUV, Material.Depth);

		int2 DownsampledScreenCoord00 = floor(ScreenUV * View.BufferSizeAndInvSize.xy / DOWNSAMPLE_FACTOR - 0.5f);
		float2 DownsampledGatherUV = (DownsampledScreenCoord00 + 1.0f) * DownsampledBufferInvSize;

		float4 CornerDepths = DownsampledSceneDepth.GatherRed(GlobalPointClampedSampler, DownsampledGatherUV).wzxy;

		int2 ScreenCoordOffset = ScreenCoord - DownsampledScreenCoord00 * 2;
		int2 SampleOffset00 = GetSampleScreenCoordJitter(DownsampledScreenCoord00 + uint2(0, 0)) + uint2(0, 0) * 2 - ScreenCoordOffset;
		int2 SampleOffset10 = GetSampleScreenCoordJitter(DownsampledScreenCoord00 + uint2(1, 0)) + uint2(1, 0) * 2 - ScreenCoordOffset;
		int2 SampleOffset01 = GetSampleScreenCoordJitter(DownsampledScreenCoord00 + uint2(0, 1)) + uint2(0, 1) * 2 - ScreenCoordOffset;
		int2 SampleOffset11 = GetSampleScreenCoordJitter(DownsampledScreenCoord00 + uint2(1, 1)) + uint2(1, 1) * 2 - ScreenCoordOffset;

		// Triangle filter weights between pixel and 4 samples
		float4 InterpolationWeights;
		InterpolationWeights.x = (2.0f - abs(SampleOffset00.x)) * (2.0f - abs(SampleOffset00.y));
		InterpolationWeights.y = (2.0f - abs(SampleOffset10.x)) * (2.0f - abs(SampleOffset10.y));
		InterpolationWeights.z = (2.0f - abs(SampleOffset01.x)) * (2.0f - abs(SampleOffset01.y));
		InterpolationWeights.w = (2.0f - abs(SampleOffset11.x)) * (2.0f - abs(SampleOffset11.y));

		float4 DepthWeights = 0.0f;	

		#define PLANE_WEIGHTING 1
		#if PLANE_WEIGHTING
		{
			float4 ScenePlane = float4(Material.WorldNormalForPositionBias, dot(TranslatedWorldPosition, Material.WorldNormalForPositionBias));

			float3 Position00 = GetTranslatedWorldPositionFromScreenUV(DownsampledScreenCoordToScreenUV(DownsampledScreenCoord00 + uint2(0, 0)), CornerDepths.x);
			float3 Position10 = GetTranslatedWorldPositionFromScreenUV(DownsampledScreenCoordToScreenUV(DownsampledScreenCoord00 + uint2(1, 0)), CornerDepths.y);
			float3 Position01 = GetTranslatedWorldPositionFromScreenUV(DownsampledScreenCoordToScreenUV(DownsampledScreenCoord00 + uint2(0, 1)), CornerDepths.z);
			float3 Position11 = GetTranslatedWorldPositionFromScreenUV(DownsampledScreenCoordToScreenUV(DownsampledScreenCoord00 + uint2(1, 1)), CornerDepths.w);

			float4 PlaneDistances;
			PlaneDistances.x = abs(dot(float4(Position00, -1), ScenePlane));
			PlaneDistances.y = abs(dot(float4(Position10, -1), ScenePlane));
			PlaneDistances.z = abs(dot(float4(Position01, -1), ScenePlane));
			PlaneDistances.w = abs(dot(float4(Position11, -1), ScenePlane));

			float4 RelativeDepthDifference = PlaneDistances / Material.Depth;

			DepthWeights = select(CornerDepths > 0.0f, exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)), 0.0f);
		}
		#else
		{
			float4 DepthDifference = abs(CornerDepths - Material.Depth.xxxx);
			float4 RelativeDepthDifference = DepthDifference / Material.Depth;

			DepthWeights = select(CornerDepths > 0.0f, exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference)), 0.0f);
		}
		#endif

		InterpolationWeights *= DepthWeights;

		// Skip out of view samples
		InterpolationWeights.x = IsValidDownsampledCoord(DownsampledScreenCoord00.xy + uint2(0, 0)) ? InterpolationWeights.x : 0.0f;
		InterpolationWeights.y = IsValidDownsampledCoord(DownsampledScreenCoord00.xy + uint2(1, 0)) ? InterpolationWeights.y : 0.0f;
		InterpolationWeights.z = IsValidDownsampledCoord(DownsampledScreenCoord00.xy + uint2(0, 1)) ? InterpolationWeights.z : 0.0f;
		InterpolationWeights.w = IsValidDownsampledCoord(DownsampledScreenCoord00.xy + uint2(1, 1)) ? InterpolationWeights.w : 0.0f;

		// Renormalize
		float Epsilon = 0.001f;
		InterpolationWeights /= max(dot(InterpolationWeights, 1), Epsilon);

		RWCompositeUpsampleWeights[ScreenCoord] = InterpolationWeights;
	}
}

#endif
